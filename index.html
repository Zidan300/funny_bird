<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skeletal Eagle Cursor</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at 50% 50%, #0a1128 0%, #000 100%);
            font-family: Arial, sans-serif;
            color: white;
            user-select: none;
        }

        /* Cinematic Moon Background */
        .moon {
            position: absolute;
            top: 10%;
            right: 15%;
            width: 100px;
            height: 100px;
            background: #e0e6ed;
            border-radius: 50%;
            box-shadow: 0 0 50px 10px rgba(130, 170, 255, 0.2);
            z-index: 0;
        }

        canvas {
            display: block;
            position: relative;
            z-index: 1;
        }

        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 17, 40, 0.9);
            padding: 30px 40px;
            border-radius: 12px;
            text-align: center;
            z-index: 10;
        }

        #gameMenu h2 {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
        }

        .target-button {
            background: #4d94ff;
            border: none;
            color: white;
            padding: 12px 24px;
            margin: 10px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .target-button:hover {
            background: #6fa6ff;
        }

        #countdownTimer {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            z-index: 10;
            user-select: none;
            text-shadow: 0 0 8px #4d94ff;
            display: none;
        }

        #resultText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 96px;
            font-weight: bold;
            color: #FFD700; /* Default to gold, overridden in JS */
            text-shadow: 0 0 20px #FFD700; /* Default, overridden in JS */
            z-index: 20;
            user-select: none;
            display: none;
        }
    </style>
</head>
<body>

<div class="moon"></div>
<canvas id="canvas"></canvas>

<div id="gameMenu">
    <h2>Choose Mosquito Kill Target</h2>
    <button class="target-button" data-target="30">30</button>
    <button class="target-button" data-target="45">45</button>
    <button class="target-button" data-target="60">60</button>
</div>

<div id="killsCounter" style="position: absolute; top: 15px; left: 20px; font-size: 26px; font-weight: bold; color: #fff; text-shadow: 0 0 8px #4d94ff; z-index: 11; user-select: none; display: none;">
    Kills: 0
</div>
<div id="countdownTimer">30</div>
<div id="resultText">GAY</div>

<button id="restartButton" style="display:none; position:absolute; left:50%; top:65%; transform:translate(-50%, -50%); background:#4d94ff; color:white; font-size:22px; font-weight:bold; border:none; border-radius:10px; padding:14px 40px; z-index:30; cursor:pointer; box-shadow:0 4px 20px #000a;">
    Restart
</button>

<script>
/**
 * SKELETAL EAGLE ANIMATION
 * Inspired by the Dragon Cursor Effect
 * Re-engineered for Raptor Anatomy & 60FPS Canvas Performance
 */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
const pointer = { x: 0, y: 0, active: false };
let idleTime = 0;
let frame = 0;

// Configuration
const cfg = {
    boneColor: '#ffffff',
    glowColor: '#4d94ff',
    segments: 12,      // Number of spine segments
    segmentDistRatio: 0.012,   // Distance between spine segments relative to canvas width
    eagleScaleRatio: 0.07,     // Scale relative to canvas width
    particleCount: 30
};

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    cfg.segmentDist = width * cfg.segmentDistRatio;
    cfg.eagleScale = width * cfg.eagleScaleRatio;
}

window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => {
    pointer.x = e.clientX;
    pointer.y = e.clientY;
    pointer.active = true;
    idleTime = 0;
});

resize();

// Initial position
pointer.x = width / 2;
pointer.y = height / 2;

class Particle {
    constructor() { this.reset(); }
    reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.life = Math.random() * 1;
    }
    draw() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.002;
        if (this.life <= 0) this.reset();
        ctx.fillStyle = `rgba(150, 200, 255, ${this.life})`;
        ctx.fillRect(this.x, this.y, 1.5, 1.5);
    }
}

class SpineSegment {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = 0;
        this.tailRotation = 0; // For dynamic tail rotation
    }
}

class SkeletalEagle {
    constructor() {
        this.spine = [];
        for (let i = 0; i < cfg.segments; i++) {
            this.spine.push(new SpineSegment(pointer.x, pointer.y));
        }
        this.flap = 0;
    }

    drawBone(x1, y1, x2, y2, thickness, glow = true) {
        ctx.beginPath();
        ctx.lineWidth = thickness;
        ctx.strokeStyle = cfg.boneColor;
        ctx.lineCap = 'round';
        if (glow) {
            ctx.shadowBlur = 14;
            ctx.shadowColor = cfg.glowColor;
        } else {
            ctx.shadowBlur = 7;
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
        }
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    drawWing(x, y, angle, side, flap) {
        const dir = side === 'left' ? -1 : 1;
        const scale = cfg.eagleScale;

        // Shoulder to Elbow (Humerus)
        const elbowAngle = angle + (Math.sin(flap) * 0.5 * dir);
        const ex = x + Math.cos(elbowAngle - (Math.PI/2 * dir)) * scale * 0.7;
        const ey = y + Math.sin(elbowAngle - (Math.PI/2 * dir)) * scale * 0.7;

        // Elbow to Wrist (Ulna/Radius)
        const wristAngle = elbowAngle + (Math.sin(flap - 0.7) * 0.8 * dir);
        const wx = ex + Math.cos(wristAngle - (Math.PI/2 * dir)) * scale * 0.8;
        const wy = ey + Math.sin(wristAngle - (Math.PI/2 * dir)) * scale * 0.8;

        // Draw wing bones
        this.drawBone(x, y, ex, ey, 5);
        this.drawBone(ex, ey, wx, wy, 3.5);

        // Primary feathers (Finger bones)
        for (let i = 0; i < 7; i++) {
            const fAngle = wristAngle + (i * 0.2 - 0.6) * dir;
            const fLen = scale * (1.1 - (i * 0.1));
            const fx = wx + Math.cos(fAngle - (Math.PI/2 * dir)) * fLen;
            const fy = wy + Math.sin(fAngle - (Math.PI/2 * dir)) * fLen;
            this.drawBone(wx, wy, fx, fy, 1);
        }
    }

    update() {
        frame += 0.015;
        
        // Idle motion: Circle around screen if mouse is still
        let targetX = pointer.x;
        let targetY = pointer.y;

        if (!pointer.active) {
            targetX = width/2 + Math.cos(frame * 0.5) * (width/3);
            targetY = height/2 + Math.sin(frame * 0.3) * (height/4);
        }

        // Leading head - increase follow speed for more immediate response
        const head = this.spine[0];
        head.x += (targetX - head.x) * 0.15;
        head.y += (targetY - head.y) * 0.15;

        // Spine segments following logic
        for (let i = 1; i < this.spine.length; i++) {
            const s = this.spine[i];
            const prev = this.spine[i - 1];
            
            const dx = prev.x - s.x;
            const dy = prev.y - s.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            s.angle = Math.atan2(dy, dx);

            if (dist > cfg.segmentDist) {
                s.x = prev.x - Math.cos(s.angle) * cfg.segmentDist;
                s.y = prev.y - Math.sin(s.angle) * cfg.segmentDist;
            }
        }

        // Dynamic tail rotation independent from spine angle for lifelike flow
        const tailStart = this.spine.length - 5;
        for(let i = tailStart; i < this.spine.length; i++) {
            const s = this.spine[i];
            s.tailRotation = Math.sin(frame * 2 + i) * 0.3;
        }

        this.flap += 0.08; // Smoother flap speed
    }

    draw() {
        const head = this.spine[0];
        const shoulder = this.spine[1];
        const angle = Math.atan2(shoulder.y - head.y, shoulder.x - head.x);

        // Draw Shadow for depth
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.ellipse(head.x, head.y + cfg.eagleScale * 1.2, cfg.eagleScale * 0.85, cfg.eagleScale * 0.28, angle, 0, Math.PI * 2);
        ctx.fill();

        // 1. Draw Tail (Back segments) with dynamic rotation
        const tailIdx = this.spine.length - 1;
        const tailBase = this.spine[tailIdx];
        for(let i = -1; i <= 1; i++) {
            const tSegment = this.spine[tailIdx];
            const tAngle = tSegment.angle + tSegment.tailRotation + (i * 0.4);
            const tx = tailBase.x - Math.cos(tAngle) * (cfg.eagleScale * 0.55);
            const ty = tailBase.y - Math.sin(tAngle) * (cfg.eagleScale * 0.55);
            this.drawBone(tailBase.x, tailBase.y, tx, ty, 1.8);
        }

        // 2. Draw Wings (Attached to the second segment/shoulder)
        this.drawWing(shoulder.x, shoulder.y, shoulder.angle, 'left', this.flap);
        this.drawWing(shoulder.x, shoulder.y, shoulder.angle, 'right', this.flap);

        // 3. Draw Ribcage/Spine
        for (let i = 0; i < this.spine.length - 1; i++) {
            const s = this.spine[i];
            const next = this.spine[i+1];
            this.drawBone(s.x, s.y, next.x, next.y, 7 - (i * 0.5));
            
            // Ribs on the first few segments
            if (i > 1 && i < 6) {
                const rAngle = s.angle + Math.PI/2;
                const rLen = (cfg.eagleScale * 0.22) - i * 1.8;
                this.drawBone(s.x, s.y, s.x + Math.cos(rAngle)*rLen, s.y + Math.sin(rAngle)*rLen, 2.5, false);
                this.drawBone(s.x, s.y, s.x - Math.cos(rAngle)*rLen, s.y - Math.sin(rAngle)*rLen, 2.5, false);
            }
        }

        // 4. Draw Head/Skull
        ctx.save();
        ctx.translate(head.x, head.y);
        ctx.rotate(head.angle);
        
        // Skull base
        ctx.fillStyle = cfg.boneColor;
        ctx.shadowBlur = 16;
        ctx.shadowColor = cfg.glowColor;
        ctx.beginPath();
        ctx.arc(0, 0, cfg.eagleScale * 0.11, 0, Math.PI * 2);
        ctx.fill();
        
        // Beak (Characteristic Eagle Hook)
        ctx.beginPath();
        ctx.moveTo(cfg.eagleScale * 0.11, -cfg.eagleScale * 0.028);
        ctx.quadraticCurveTo(cfg.eagleScale * 0.25, -cfg.eagleScale * 0.028, cfg.eagleScale * 0.28, cfg.eagleScale * 0.055);
        ctx.lineTo(cfg.eagleScale * 0.17, cfg.eagleScale * 0.055);
        ctx.fill();
        ctx.restore();
    }
}

const eagle = new SkeletalEagle();
const particles = Array.from({ length: cfg.particleCount }, () => new Particle());

// Mosquito System (Integrated Version)
const mosquitoImg = new Image();
mosquitoImg.src = "musquito.png";

const screamSound = new Audio();
screamSound.src = "./scream.mp3";
screamSound.preload = "auto";
screamSound.load();
screamSound.volume = 0.7;
screamSound.addEventListener('error', (e) => {
    console.error('Sound failed to load. Check file path for scream.mp3');
});

// BloodParticle class for blood blast effect
class BloodParticle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1;
        this.size = Math.random() * 2 + 1;
        this.gravity = 0.05;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.life -= 0.03;
    }
    draw() {
        ctx.fillStyle = `rgba(255, 0, 0, ${this.life})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
    isDead() {
        return this.life <= 0;
    }
}

const bloodParticles = [];

class Mosquito {
    constructor() {
        this.reset();
        this.setRespawnTimeout();
    }

    reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height * 0.6;
        this.opacity = 1;
        this.alive = true;
        this.falling = false;
        this.vy = 0;
        this.rotation = 0;
        this.size = cfg.eagleScale * 0.45;
        this.deadTimer = 0;
        this.clearRespawnTimeout();
        this.setRespawnTimeout();
    }

    setRespawnTimeout() {
        this.respawnTimeout = setTimeout(() => {
            if (!this.falling) {
                this.reset();
            }
            this.setRespawnTimeout();
        }, 1000 + Math.random() * 2000);
    }

    clearRespawnTimeout() {
        if (this.respawnTimeout) {
            clearTimeout(this.respawnTimeout);
            this.respawnTimeout = null;
        }
    }

    update() {
        if (this.alive) {
            this.opacity -= 0.008;
            if (this.opacity <= 0) {
                this.reset();
            }
        } else if (this.falling) {
            this.vy += 0.25;
            this.y += this.vy;
            if (this.y >= height - this.size / 2) {
                this.y = height - this.size / 2;
                this.vy = 0;
                this.falling = false;
                this.deadTimer = 120;
            }
        } else {
            if (this.deadTimer > 0) {
                this.deadTimer--;
            } else {
                this.reset();
            }
        }
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        // Draw mosquito image
        ctx.drawImage(
            mosquitoImg,
            -this.size / 2,
            -this.size / 2,
            this.size,
            this.size
        );
        // Draw glow effect
        ctx.globalAlpha = this.opacity * 0.5;
        ctx.shadowColor = "#ffeb3b";
        ctx.shadowBlur = 24;
        ctx.beginPath();
        ctx.arc(0, 0, this.size * 0.65, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,80,0.15)";
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
        ctx.globalAlpha = 1;
    }

    kill() {
        this.alive = false;
        this.falling = true;
        this.opacity = 1;
        this.rotation = Math.PI;
        this.vy = 2;
        screamSound.currentTime = 0;
        screamSound.play();
        // Spawn more blood particles at mosquito location
        const bloodCount = 35;
        for(let i = 0; i < bloodCount; i++) {
            bloodParticles.push(new BloodParticle(this.x, this.y));
        }
    }
}

const mosquitoes = [];
for(let i = 0; i < 7; i++) {
    mosquitoes.push(new Mosquito());
}

// GAME LOGIC ADDITIONS
const gameMenu = document.getElementById('gameMenu');
const countdownTimer = document.getElementById('countdownTimer');
const resultText = document.getElementById('resultText');
const killsCounter = document.getElementById('killsCounter');
const restartButton = document.getElementById('restartButton');

let gameStarted = false;
let gameDuration = 30; // seconds
let timeLeft = gameDuration;
let killTarget = 0;
let kills = 0;
let countdownInterval = null;
let animationActive = false;
let congregationParticles = [];

class CongregationParticle {
    constructor() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.size = Math.random() * 4 + 2;
        this.vx = (Math.random() - 0.5) * 1.5;
        this.vy = (Math.random() - 0.5) * 1.5;
        this.life = 1;
        this.color = `rgba(77, 148, 255, 1)`;
        this.glow = 0;
        this.glowDir = 1;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        if(this.x < 0) this.x = width;
        if(this.x > width) this.x = 0;
        if(this.y < 0) this.y = height;
        if(this.y > height) this.y = 0;
        this.glow += this.glowDir * 0.05;
        if(this.glow > 1) this.glowDir = -1;
        if(this.glow < 0) this.glowDir = 1;
    }
    draw() {
        ctx.save();
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20 * this.glow;
        ctx.fillStyle = `rgba(77, 148, 255, ${0.7 + 0.3 * this.glow})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

function startGame(target) {
    killTarget = target;
    kills = 0;
    timeLeft = gameDuration;
    gameStarted = true;
    animationActive = true;
    gameMenu.style.display = 'none';
    countdownTimer.style.display = 'block';
    resultText.style.display = 'none';
    killsCounter.style.display = 'block';
    killsCounter.textContent = `Kills: 0`;
    restartButton.style.display = 'none';
    congregationParticles = [];

    // Play scream sound at start
    screamSound.currentTime = 0;
    screamSound.play();

    countdownTimer.textContent = timeLeft;

    // Reset eagle position to center
    pointer.x = width / 2;
    pointer.y = height / 2;
    pointer.active = false;

    // Reset mosquitoes
    mosquitoes.forEach(m => m.reset());

    // Start countdown interval
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(() => {
        timeLeft--;
        countdownTimer.textContent = timeLeft;
        if(timeLeft <= 0) {
            clearInterval(countdownInterval);
            endGame();
        }
    }, 1000);
}

function endGame() {
    animationActive = false;
    countdownTimer.style.display = 'none';
    killsCounter.style.display = 'block';
    restartButton.style.display = 'block';

    if(kills >= killTarget) {
        // Show "NOT GAY" text and congregation animation together
        resultText.textContent = 'NOT GAY';
        resultText.style.display = 'block';
        // Set gold color and glow for success
        resultText.style.color = '#FFD700';
        resultText.style.textShadow = '0 0 20px #FFD700';
        startCongregationAnimation();
    } else {
        // Show "GAY" text
        resultText.textContent = 'GAY';
        resultText.style.display = 'block';
        // Set red color and glow for failure
        resultText.style.color = '#ff1a1a';
        resultText.style.textShadow = '0 0 32px #ff1a1a, 0 0 64px #ff1a1a';
    }
}

function startCongregationAnimation() {
    congregationParticles = [];
    for(let i = 0; i < 100; i++) {
        congregationParticles.push(new CongregationParticle());
    }
    // Show for 5 seconds then hide
    // resultText.style.display = 'none'; // Remove hiding so text remains visible
    congregationAnimationActive = true;
    setTimeout(() => {
        congregationAnimationActive = false;
        congregationParticles = [];
        // Don't show menu here; handled by restart button
    }, 5000);
}

let congregationAnimationActive = false;

// Update animate function to incorporate game logic
function animate() {
    ctx.clearRect(0, 0, width, height);
    
    particles.forEach(p => p.draw());

    if(animationActive) {
        mosquitoes.forEach(mosquito => {
            mosquito.update();
            mosquito.draw();
        });
        
        eagle.update();
        eagle.draw();

        // Collision detection with eagle head for each mosquito
        const head = eagle.spine[0];
        mosquitoes.forEach(mosquito => {
            const dx = head.x - mosquito.x;
            const dy = head.y - mosquito.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (mosquito.alive && distance < cfg.eagleScale * 0.2) {
                mosquito.kill();
                kills++;
                killsCounter.textContent = `Kills: ${kills}`;
                // Play scream on kill already handled in kill()
            }
        });

        // Update and draw blood particles
        for(let i = bloodParticles.length - 1; i >= 0; i--) {
            const p = bloodParticles[i];
            p.update();
            p.draw();
            if (p.isDead()) {
                bloodParticles.splice(i, 1);
            }
        }
    } else {
        // If not started, still update eagle and particles but no mosquitoes
        eagle.update();
        eagle.draw();
        for(let i = bloodParticles.length - 1; i >= 0; i--) {
            const p = bloodParticles[i];
            p.update();
            p.draw();
            if (p.isDead()) {
                bloodParticles.splice(i, 1);
            }
        }
    }

    // Draw congregation animation if active
    if(congregationAnimationActive) {
        congregationParticles.forEach(particle => {
            particle.update();
            particle.draw();
        });
    }

    requestAnimationFrame(animate);
}

animate();

// Hook up menu buttons
const buttons = document.querySelectorAll('.target-button');
buttons.forEach(button => {
    button.addEventListener('click', () => {
        const target = parseInt(button.getAttribute('data-target'));
        startGame(target);
    });
});

// Restart button logic
restartButton.addEventListener('click', () => {
    restartButton.style.display = 'none';
    killsCounter.style.display = 'none';
    resultText.style.display = 'none';
    gameMenu.style.display = 'block';
});
</script>
</body>
</html>